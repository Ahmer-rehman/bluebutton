<?xml version="1.0" encoding="utf-8"?>

<!--
  BigBlueButton open source conferencing system - http://www.bigbluebutton.org
  
  Copyright (c) 2010 BigBlueButton Inc. and by respective authors (see below).
  
  BigBlueButton is free software; you can redistribute it and/or modify it under the 
  terms of the GNU Lesser General Public License as published by the Free Software 
  Foundation; either version 2.1 of the License, or (at your option) any later 
  version. 
  
  BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY 
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
  PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public License along 
  with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
 
  $Id: $

	Ismael Rumzan change log (April 17-30 2011):
	- zoom from center - fixed
	- moving image - fixed
	- reset zoom - for now leave it to only resize back to 100 - in future look into reseting position
	- mousewheel zoom - broadcast so that slider can be adjusted and others listen - need to unit test
	- ensure particpants also get updated - close need to make sure participants zoom is from center - fixed
	- On resize window (both mod and participant) - the slide gets moved around - fixed
	- Disable move for participant - fixed
	- Move slide with moderator move - fixed
	
Need to work on:

	2 bugs found 
	1. when zoomed in to x%, moved to x,y and them zoomed again, the zoom does not go from the full center 
	works best when zoomed back to 100, moved and then zoomed again
	2. Zooming from mouse wheel as center works partly - as zoom increases, it drifts away from mouse wheel center to top left

-->

<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" 
	xmlns:mate="http://mate.asfusion.com/"
	xmlns:local="*"
    paddingBottom="5" 
    creationComplete="onCreationComplete()" verticalScrollPolicy="off" horizontalScrollPolicy="off"      
    rollOut="hideCursor()"
    xmlns:views="org.bigbluebutton.modules.present.views.*"
    implements="org.bigbluebutton.common.IBbbCanvas">
    
    <mate:Listener type="{ZoomEvent.ZOOM}" method="handleZoomEvent" />
    <mate:Listener type="{MoveEvent.MOVE}" method="handleMoveEvent" />
    <mate:Listener type="{SlideEvent.SLIDE_LOADED}" method="handleSlideLoadedEvent" />
    <mate:Listener type="{MadePresenterEvent.SWITCH_TO_PRESENTER_MODE}" method="handleSwitchToPresenterEvent" />
    <mate:Listener type="{MadePresenterEvent.SWITCH_TO_VIEWER_MODE}" method="handleSwitchToViewerEvent" />
    <mate:Listener type="{CursorEvent.UPDATE_CURSOR}" method="handleUpdateCursorEvent" />
    <mate:Listener type="{WindowResizedEvent.PRESENTATION_WINDOW_RESIZED_EVENT}" method="handleWindowResizeEvent"/>
    <mate:Listener type="{PresenterCommands.RESIZE}" method="handleSlideResizeEvent"/>
	<mate:Listener type="{PresenterCommands.ENABLE_MOVE}" method="endZoom"/>
	<mate:Listener type="{PresenterCommands.DISABLE_MOVE}" method="initZoom"/>
	<mate:Listener type="{PresenterCommands.RESET_ZOOM}" method="resetZoom"/>	
	<mate:Listener type="{PresenterCommands.MOUSEWHEEL_UPDATE}" method="setCenter"/>
    
	<mx:Script>
		<![CDATA[
			import com.asfusion.mate.events.Dispatcher;
			
			import flash.events.Event;
			
			import mx.binding.utils.BindingUtils;
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.controls.Button;
			import mx.events.FlexEvent;
			import mx.events.ListEvent;
			
			import org.bigbluebutton.common.IBbbCanvas;
			import org.bigbluebutton.main.events.MadePresenterEvent;
			import org.bigbluebutton.modules.present.events.CursorEvent;
			import org.bigbluebutton.modules.present.events.DisplaySlideEvent;
			import org.bigbluebutton.modules.present.events.MoveEvent;
			import org.bigbluebutton.modules.present.events.PresenterCommands;
			import org.bigbluebutton.modules.present.events.SlideEvent;
			import org.bigbluebutton.modules.present.events.SlideResizedEvent;
			import org.bigbluebutton.modules.present.events.UploadEvent;
			import org.bigbluebutton.modules.present.events.WindowResizedEvent;
			import org.bigbluebutton.modules.present.events.ZoomEvent;

			public var zoomPercentage:int = 100;
			public static const ZOOM_STEP:int = 5;
			public static const THUMBNAILS_CLOSED:String = "ThumbnailsClosed";
			
			/**
			 * Variables that holds the presenter's locations of the
			 * loader so we can move the participant's slides in the
			 * same scale to maintain sync on the presenter's cursor.
			 */ 
			private var presentersLoaderXOffsetFromCanvas:Number = 0;
			private var presentersLoaderYOffsetFromCanvas:Number = 0;
			
			/**
			 * Variables that stores the presenter's ratio between
			 * loader and canvas. We need to size the slide with the
			 * same scale as the presenter so that the cursor syncs
			 * properly.
			 */
			private var presentersLoaderCanvasWidthRatio:Number = 1;
			private var presentersLoaderCanvasHeightRatio:Number = 1;
			
			private var canvasMouseXOnMouseDown:int;
			private	var canvasMouseYOnMouseDown:int;
			private var loaderXOnMouseDown:int;
			private var loaderYOnMouseDown:int;
						
			private var cursor:Shape;
			private var overlayChildrenHolder:Canvas = new Canvas();
			private var overlayCanvas:IBbbCanvas;
			
			//The following few variables concern text selection
			private var slideClip:MovieClip;
			private var slideText:TextSnapshot;
			private var firstChar:Number = -1;
			private var lastChar:Number = -1;
			private var moveEnabled:Boolean = true;
			private var startX:int = 0;
			private var startY:int = 0;
			private var startImgX:int = 0;
			private var startImgY:int = 0;
			private var scaleFactor:Number = 1;
			private var tolerance:int = 50;
			private var xcenter:int;
			private var ycenter:int;
			private var startWidth:int;
			private var startHeight:int;
			private var enableZoomWheel:Boolean = false;
				
        	[Bindable] public var slides:ArrayCollection;
			[Bindable] public var selectedSlide:int=0;
			[Bindable] private var isPresenter:Boolean = false;
			
			private var dispatcher:Dispatcher = new Dispatcher();
				
			private function onCreationComplete():void {
				slideLoader.width = this.width;
				slideLoader.height = this.height;
				
				initSize();
				
				cursor = new Shape();
				cursor.graphics.lineStyle(6, 0xFF0000, 0.6);
				cursor.graphics.drawCircle(0,0,3);
				this.rawChildren.addChild(cursor);
				cursor.visible = false;
				
				overlayChildrenHolder = new Canvas();
				this.addChild(overlayChildrenHolder);
				overlayChildrenHolder.x = 0;
				overlayChildrenHolder.y = 0;
				
				this.setChildIndex(thumbnailView, this.numChildren - 1);
			}
						
			public function setSlides(slides:ArrayCollection):void {
				this.slides = slides;
				thumbnailView.dataProvider = this.slides.toArray();
			}
			
			private function changeSlide():void {
				dispatchEvent(new PresenterCommands(PresenterCommands.GOTO_SLIDE, thumbnailView.selectedIndex));
				thumbnailView.visible = false;
				showOverlayCanvas(true);
				dispatchEvent(new Event(THUMBNAILS_CLOSED));
			}
			
			private function changeIndex(e:ListEvent):void {
				dispatchEvent(e);
			}
			
			//=== Modifications of zooming, panning and resizing
			
			//==== Resize loader on load and window resize
			
			/**
			 * Handles the resizing of the presenter's window. This is for the presenter resizing
			 * his/her window.
			 */
			private function handleWindowResizeEvent(event:WindowResizedEvent):void {						
				
				this.width = event.width;
				this.height = event.height;
				
				synchSizes(this.width,this.height);	

				setZoomInitialStatus();
				//If image was zoomed before resize event, put it back to it's zoomed state
				zoomImage();
				
			}
			
			private function synchSizes(_width:int,_height:int):void {
				
				container.width = _width;
				container.height = _height;
				
				slideLoader.width = container.width;
				slideLoader.height = container.height;
				
			}
			
			private function setStartSize():void {
				
				if (noSlideContentLoaded()) return;
				
				synchSizes(this.width,this.height);
				
				setZoomInitialStatus();
				
			}
			
			private function setZoomInitialStatus():void {
				startWidth = container.width;
				startHeight = container.height;			
				initSize();
			}
			
			private function handleSlideResizeEvent(event:PresenterCommands):void {	
				
				scaleFactor = event.newSizeInPercent/100;
				zoomImage();
				
			}
			
			//===== Listen to slider zooming in and out and zoom from center
			
			private function initSize():void {
				xcenter = this.width/2;
				ycenter = this.height/2;
			}
			
			private function zoomImage():void {
				
				var newW:int = scaleFactor*startWidth;
				var newH:int = scaleFactor*startHeight;
				
				synchSizes(newW,newH);
				
				var newX:int = (startImgX - scaleFactor*xcenter) + xcenter;
				var newY:int = (startImgY - scaleFactor*ycenter) + ycenter;
				
				container.x = newX;
				container.y = newY;
				
				checkBounds();
				
				notifyOthersOfZoomEvent();
				
			}
			
			private function zoomForViewer(sf:int,startXRatio:Number,startYRatio:Number,xcenterRatio:Number,ycenterRatio:Number):void {
				
				synchSizes(presentersLoaderCanvasWidthRatio*this.width,presentersLoaderCanvasHeightRatio*this.height);
				
				var newX:int = (startXRatio*this.width - sf*xcenterRatio*this.width) + xcenterRatio*this.width;
				var newY:int = (startYRatio*this.height - sf*ycenterRatio*this.height) + ycenterRatio*this.height;
				
				container.x = newX;
				container.y = newY;
					
			}
			
			private function initZoom(evt:PresenterCommands):void {
				initSize();
				moveEnabled = false;
			}
			
			private function endZoom(evt:PresenterCommands):void {
				moveEnabled = true;
			}
			
			private function resetZoom(evt:PresenterCommands):void {
				scaleFactor = evt.newSizeInPercent/100;
				container.x = this.x;
				container.y = this.y;
				initSize();
				zoomImage();
			}
			
			//====== Move image with mouse
			
			private function enableMove(evt:MouseEvent):void {
				if (moveEnabled&&isPresenter) {
					startX = evt.localX;
					startY = evt.localY;
					container.addEventListener(MouseEvent.MOUSE_MOVE,moveImage);
					stage.addEventListener(MouseEvent.MOUSE_UP,disableMove);
				}
			}
			
			private function disableMove(evt:MouseEvent):void {
				if (moveEnabled&&isPresenter) {
					container.removeEventListener(MouseEvent.MOUSE_MOVE,moveImage);
					stage.removeEventListener(MouseEvent.MOUSE_UP,disableMove);
					checkBounds();
					startImgX = container.x/scaleFactor;
					startImgY = container.y/scaleFactor;
				}	
			}
			
			private function moveImage(evt:MouseEvent):void {
				
				container.x = container.x + (evt.localX - startX);
				container.y = container.y + (evt.localY - startY);
				
				startImgX = container.x/scaleFactor;
				startImgY = container.y/scaleFactor;
				
				notifyOthersOfZoomEvent();
				
			}
			
			//===== Handle zooming from mouse center if mouse wheel is used
			private function setCenter(evt:PresenterCommands):void {
				xcenter = evt.localX;
				ycenter = evt.localY;
			}
			
			//======= Ensure does not go out of bounds
			
			private function checkBounds():void {
				
				if (container.x <= (this.x - container.width + tolerance)) {
					container.x = this.x;
				} else if (container.x >= (this.x + this.width - tolerance)) {
					container.x = this.x;
				} 
				
				if (container.y <= (this.y - container.height + tolerance)) {
					container.y = this.y;
				} else if (container.y >= (this.y + this.height - tolerance)) {
					container.y = this.y;
				} 
			}
			
			//========================================================================
			
			public function notifyListenersOfSlideResize(percent:Number):void {
				var event:SlideResizedEvent = new SlideResizedEvent();
				event.percent = percent;
				dispatcher.dispatchEvent(event);
			}
						
			private function notifyOthersOfZoomEvent():void {
				var presentEvent:PresenterCommands = new PresenterCommands(PresenterCommands.ZOOM);
				presentEvent.xOffset = startImgX/this.width;
				presentEvent.yOffset = startImgY/this.height;
				presentEvent.slideToCanvasWidthRatio = slideLoader.width/this.width;
				presentEvent.slideToCanvasHeightRatio = slideLoader.height/this.height;
				dispatchEvent(presentEvent);
			}
			
			private function presenterIsZoomingOut(delta:Number):Boolean {
				// If delta is negative, the presenter is zooming-out of the presentation.
				return delta < 0;
			}
			
			/**
			 * Handles notification from presenter that the slide has moved.
			 */
			private function handleMoveEvent(e:MoveEvent):void{
				savePresentersSettings(e.xOffset, e.yOffset, e.slideToCanvasWidthRatio, e.slideToCanvasHeightRatio);				
				if (!isPresenter) {
					resizeAndMoveLoaderInRelationToCanvas();
				}
				
				moveCanvas(slideLoader.x, slideLoader.y);
			}
			
			/**
			 * Handle notification from presenter that the slide has been zoomed.
			 */						
			private function handleZoomEvent(e:ZoomEvent):void {
				
				savePresentersSettings(e.xOffset, e.yOffset, e.slideToCanvasWidthRatio, e.slideToCanvasHeightRatio);													
				if (!isPresenter) {
					resizeAndMoveLoaderInRelationToCanvas();
				}
	
			}
			
			private function resizeAndMoveLoaderInRelationToCanvas():void {
				
				var newW:int = this.width * presentersLoaderCanvasWidthRatio; 
				var newH:int = this.height * presentersLoaderCanvasHeightRatio;
				
				var newX:int = (presentersLoaderXOffsetFromCanvas*this.width - presentersLoaderCanvasWidthRatio*xcenter) + xcenter;
				var newY:int = (presentersLoaderYOffsetFromCanvas*this.height - presentersLoaderCanvasHeightRatio*ycenter) + ycenter;
				
				synchSizes(newW,newH);
				
				container.x = newX;
				container.y = newY;
			}
			
			/**
			 * Handle notification from loader that a slide has been loaded.
			 */						
			private function handleSlideLoadedEvent(e:SlideEvent):void{
				slideLoader.source = e.slide;
			}
			
			/**
			 * Handle the event where this presenter becomes a viewer because another attendee became presenter.
			 */			
			private function handleSwitchToViewerEvent(e:MadePresenterEvent):void{
				participantIsNowPresenter(false);
				dispatchEvent(new PresenterCommands(PresenterCommands.MOUSEWHEEL_DISABLE));
				container.removeEventListener(MouseEvent.MOUSE_DOWN, enableMove);
				//this.removeEventListener(MouseEvent.MOUSE_OUT, setMouseOut);
				enableZoomWheel = false;
			}
			
			/**
			 * Makes the attendee the presenter.
			 */
			private function handleSwitchToPresenterEvent(e:MadePresenterEvent):void{
				participantIsNowPresenter(true);
				dispatchEvent(new PresenterCommands(PresenterCommands.MOUSEWHEEL_ENABLE));
				container.addEventListener(MouseEvent.MOUSE_DOWN, enableMove);
				//this.addEventListener(MouseEvent.MOUSE_OUT, setMouseOut);
				enableZoomWheel = true;
			}
			
			private function participantIsNowPresenter(presenter:Boolean):void {
				this.isPresenter = presenter;
			}
			
			/**
			 * Listen for mouse events to track the cursor.
			 */			
			public function mouseCursorUpdateListener(e:MouseEvent):void{
				if (noSlideContentLoaded()) return;				
				notifyOthersOfPresentersCursorPosition(this.mouseX, this.mouseY);
			}
			
			/**
			 * Broadcast to other participants the location fo the mouse cursor.
			 */
			private function notifyOthersOfPresentersCursorPosition(cursorXPosition:int, cursorYPosition:int):void {
				var command:PresenterCommands = new PresenterCommands(PresenterCommands.SEND_CURSOR_UPDATE);				
				command.xPercent = cursorXPosition / this.width;
				command.yPercent = cursorYPosition / this.height;				
				dispatchEvent(command);
			}
			
			/**
			 * Handle notification from presenter about the location of the mouse cursor.
			 */
			private function handleUpdateCursorEvent(e:CursorEvent):void{
				if (noSlideContentLoaded()) return;
				
				cursor.x = e.xPercent * this.width;
				cursor.y = e.yPercent * this.height;
								
				if (isCursorOutsideWindow(e)) {
					hideCursor()
				} else {
					showCursor();
				}	
			}
			
			private function noSlideContentLoaded():Boolean {
				return slideLoader.content == null
			}
			
			/**
			 * Keep track of the presenter's x,y coordinates and the size of his/her presentation window.
			 */
			private function savePresentersSettings(xOffset:Number, yOffset:Number, widthRatio:Number, heightRatio:Number):void {
				presentersLoaderXOffsetFromCanvas = xOffset;
				presentersLoaderYOffsetFromCanvas = yOffset;
				presentersLoaderCanvasWidthRatio = widthRatio;
				presentersLoaderCanvasHeightRatio = heightRatio;
			}
			
			/*
			 * Fire an event when a single slide has been loaded.
			 */
			private function listenForSlideLoadedCompleteEvent():void {
				slideLoader.addEventListener(Event.COMPLETE, handleSlideLoadedCompleteEvent);
			}
			
			private function handleSlideLoadedCompleteEvent(event:Event):void {		
				var slideRealWidth:int = slideLoader.content.width;
				var slideRealHeight:int = slideLoader.content.height;				
				//fitLoaderToCanvas();
				setStartSize();
				initSize();
				trace(xcenter+":"+ycenter+":"+isPresenter);
				dispatchNewSlideDisplayedEvent(slideRealWidth, slideRealHeight);				
			}
			
			private function dispatchNewSlideDisplayedEvent(slideRealWidth:int, slideRealHeight:int):void {
				var dispEvent:DisplaySlideEvent = new DisplaySlideEvent(DisplaySlideEvent.DISPLAY_SLIDE_EVENT);
				dispEvent.slideWidth = slideRealWidth;
				dispEvent.slideHeight = slideRealHeight;
				dispatcher.dispatchEvent(dispEvent);
			}
						
			private function isCursorOutsideWindow(e:CursorEvent):Boolean {
				return (e.xPercent > 1 && e.yPercent > 1) || (cursor.x > this.width || cursor.y > this.height);
			}
			
			private function showCursor():void {
				cursor.visible = true;
			}
			
			private function hideCursor():void{
				cursor.visible = false;
			}			
			
			/** Inherited from IBbbCanvas*/
			public function addRawChild(child:DisplayObject):void{
				this.overlayChildrenHolder.rawChildren.addChild(child);
			}
			
			public function removeRawChild(child:DisplayObject):void{
				this.overlayChildrenHolder.rawChildren.removeChild(child);
			}
			
			public function doesContain(child:DisplayObject):Boolean{
				return this.overlayChildrenHolder.rawChildren.contains(child);
			}
			
			public function acceptOverlayCanvas(overlay:IBbbCanvas):void{
				overlayCanvas = overlay;
				var c:Canvas = overlay as Canvas;
				this.addChild(c);
				c.x = 0;
            	c.y = 0;
			}
			
			public function moveCanvas(x:int, y:int):void{
				overlayChildrenHolder.x = slideLoader.x * 2;
				overlayChildrenHolder.y = slideLoader.y * 2;
				
				if (overlayCanvas != null) overlayCanvas.moveCanvas(overlayChildrenHolder.x, overlayChildrenHolder.y);
			}
			
			public function zoomCanvas(width:int, height:int):void{
				overlayChildrenHolder.width = width;
				overlayChildrenHolder.height = height;
				moveCanvas(slideLoader.x, slideLoader.y);
				if (overlayCanvas != null) overlayCanvas.zoomCanvas(width, height);
			}
			
			public function showOverlayCanvas(show:Boolean):void{
				overlayCanvas.showCanvas(show);
			}
			
			public function showCanvas(show:Boolean):void{
				
			}
			
		]]>
	</mx:Script>
	<mx:Canvas id="container" width="100%" height="100%" 
			   horizontalScrollPolicy="off" verticalScrollPolicy="off"
			   mouseDown="enableMove(event)">
		<mx:SWFLoader id="slideLoader" width="100%" height="100%" 
					  creationComplete="listenForSlideLoadedCompleteEvent()"
    		scaleContent="true" maintainAspectRatio="true" showBusyCursor="true" completeEffect="Fade"/>   
    </mx:Canvas>
    <mx:HorizontalList id="thumbnailView" itemRenderer="org.bigbluebutton.modules.present.views.Thumbnail" itemRollOver="changeIndex(event)" 
    	visible="false" width="100%" height="100" y="{this.height - 100}" change="changeSlide()" />
    
		      		 
</mx:Canvas>
