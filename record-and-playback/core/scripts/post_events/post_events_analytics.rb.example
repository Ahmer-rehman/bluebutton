#!/usr/bin/ruby
# encoding: UTF-8

#
# BigBlueButton open source conferencing system - http://www.bigbluebutton.org/
#
# Copyright (c) 2019 BigBlueButton Inc. and by respective authors (see below).
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU Lesser General Public License as published by the Free
# Software Foundation; either version 3.0 of the License, or (at your option)
# any later version.
#
# BigBlueButton is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.
#

require 'net/http'
require "jwt"
require 'bbbevents'
require 'socket'
require "trollop"
require File.expand_path('../../../lib/recordandplayback', __FILE__)

def send_data(analytics_url, secret, payload)
  # Setup a token that expires in 24hrs
  exp = Time.now.to_i + 24 * 3600
  exp_payload = { :exp => exp }
  token = JWT.encode exp_payload, secret, 'HS512', { typ: 'JWT' }

  uri = URI.parse(analytics_url)
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = (uri.scheme == 'https')

  # Setup a request and attach our JWT token
  request = Net::HTTP::Post.new(uri.request_uri, {
    'Content-Type' => 'application/json',
    'Authorization' => "Bearer #{token}",
    'User-Agent' => 'BigBlueButton Analytics Callback'
  })

  # Send out data as json body
  request.body = payload.to_json

  # Display debug results
  #http.set_debug_output($stdout) 

  response = http.request(request)
  code = response.code.to_i
  puts response.body

  if code < 200 || code >= 300
    puts "Failed when calling #{uri.request_uri}"
  else
    puts "Success"
  end
end

def format_analytics_data!(data)
  tmp_metadata = data["metadata"]
  array_keys = tmp_metadata.keys
  array_keys.each { |item|
    if item.start_with?("gl_")
      tmp_metadata = tmp_metadata.tap { |hs|
        hs.delete(item) 
      }
    end
  }

  # Remove meeting id as we don't want it passed to 3rd party inside metadata
  tmp_metadata.delete("meeting_id")

  # Remove the internal meeting id generated by bbbevents gem
  data = data.tap { |hs|
    hs.delete("meeting_id") 
  }

  # Convert CamelCase keys to snake_keys. This is done in bbbevents gem
  # but we do it here too anyways.
  tmp_metadata.deep_transform_keys! do |key|
    k = key.to_s.underscore rescue key
    k.to_sym rescue key
  end       

  # Remove all internal user ids
  attendees = data["attendees"]
  attendees.each { |attendee|
    attendee.delete("id")
  }

end

opts = Trollop::options do
  opt :meeting_id, "Meeting id to archive", :type => String
end
meeting_id = opts[:meeting_id]

i_got_this = false
if not i_got_this
  BigBlueButton.logger.info("######################################################")
  BigBlueButton.logger.info("!!! Please read setup instructions in bottome of this script. !!!")
  BigBlueButton.logger.info("######################################################")
  exit 0
end


logger = Logger.new(STDOUT)
#logger = Logger.new("/var/log/bigbluebutton/post_events.log", 'weekly' )
logger.level = Logger::INFO
BigBlueButton.logger = logger

archived_files = "/var/bigbluebutton/recording/raw/#{meeting_id}"
meeting_metadata = BigBlueButton::Events.get_meeting_metadata("#{archived_files}/events.xml")

props = YAML::load(File.open('bigbluebutton.yml'))

events_xml_path = "#{archived_files}/events.xml"
data_json_path = "#{archived_files}/data.json"

if meeting_metadata["analytics_callback_url"] != nil
  analytics_callback_url = meeting_metadata["analytics_callback_url"]

  # Parse the events.xml.
  events_data = BBBEvents.parse(events_xml_path)

  # Write JSON data to file.
  File.open(data_json_path, 'w') do |f|
    f.write(events_data.to_json)
  end  

  json_file = File.open data_json_path
  data = JSON.load(json_file)

  format_analytics_data!(data)

  # Get the external meeting id
  external_meeting_id = meeting_metadata["meetingId"]

  data_version_format = "1.0"

  payload = { version: data_version_format,
    ext_meeting_id: external_meeting_id, 
    meeting_id: meeting_id,
    data: data
  }

  # Convert CamelCase keys to snake_keys for the whole payload.
  # This is a sledgehammer to force keys to be consistent.
  payload.deep_transform_keys! do |key|
    k = key.to_s.underscore rescue key
    k.to_sym rescue key
  end

  #puts payload.to_json

  secret = "my_secret" #or the shared secret from bbb.properties
  send_data(analytics_callback_url, secret, payload)
end



exit 0


##################
#### Setup instructions
# Modify core/Gemfile by adding
#
# gem "jwt"
# gem 'bbbevents', git: 'https://github.com/ritzalam/bbb-events.git', branch: 'v2-dev'
# ^ 
# |- Will replace to proper release when builds failures are fixed.
# 
# bundle install
# 
# Edit /usr/share/bbb-web/WEB-INF/classes/bigbluebutton.properties
#  set keepEvents=true
#
# Restart bigbluebutton
# Create meeting and pass `analytics_callback_url` as meta params (i.e. meta_analytics_callback_url)
#
# Once the meeting is finished, the callback url will be called.
#
# For testing, take any events.xml file and add analytics callback into metadata.
#
# <metadata gl-listed="false" 
#           isBreakout="false" 
#           meetingId="9f6ca4f7756c1255038d5f0d3f4bc2622402f953" 
#           meetingName="My Demo Meeting" 
#           analytics_callback_url="https://postman-echo.com/post"/>
#
# Then in /usr/local/bigbluebutton/core/scripts 
#   bundle exec ruby post_events/post_events_analytics.rb -m <meeting id>
# e.g
#   bundle exec ruby post_events/post_events_analytics.rb -m f805af69d6fe5c459631a592bf32f12383ed03c0-1563463942198
#

#
